/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _require = require('./ReactFiberUpdateQueue'),
    addTopLevelUpdate = _require.addTopLevelUpdate;

var _require2 = require('./ReactFiberContext'),
    findCurrentUnmaskedContext = _require2.findCurrentUnmaskedContext,
    isContextProvider = _require2.isContextProvider,
    processChildContext = _require2.processChildContext;

var _require3 = require('./ReactFiberRoot'),
    createFiberRoot = _require3.createFiberRoot;

var ReactFiberScheduler = require('./ReactFiberScheduler');

if (process.env.NODE_ENV !== 'production') {
  var ReactFiberInstrumentation = require('./ReactFiberInstrumentation');
}

var _require4 = require('./ReactFiberTreeReflection'),
    findCurrentHostFiber = _require4.findCurrentHostFiber;

var getContextForSubtree = require('./getContextForSubtree');

getContextForSubtree._injectFiber(function (fiber) {
  var parentContext = findCurrentUnmaskedContext(fiber);
  return isContextProvider(fiber) ? processChildContext(fiber, parentContext, false) : parentContext;
});

module.exports = function (config) {
  var _ReactFiberScheduler = ReactFiberScheduler(config),
      scheduleUpdate = _ReactFiberScheduler.scheduleUpdate,
      getPriorityContext = _ReactFiberScheduler.getPriorityContext,
      performWithPriority = _ReactFiberScheduler.performWithPriority,
      batchedUpdates = _ReactFiberScheduler.batchedUpdates,
      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
      syncUpdates = _ReactFiberScheduler.syncUpdates,
      deferredUpdates = _ReactFiberScheduler.deferredUpdates;

  function scheduleTopLevelUpdate(current, element, callback) {
    var priorityLevel = getPriorityContext();
    var nextState = { element: element };
    addTopLevelUpdate(current, nextState, callback || null, priorityLevel);
    scheduleUpdate(current, priorityLevel);
  }

  return {
    createContainer: function (containerInfo) {
      var root = createFiberRoot(containerInfo);
      var current = root.current;

      // It may seem strange that we don't return the root here, but that will
      // allow us to have containers that are in the middle of the tree instead
      // of being roots.
      return current;
    },
    updateContainer: function (element, container, parentComponent, callback) {
      // TODO: If this is a nested container, this won't be the root.
      var root = container.stateNode;
      var current = root.current;

      if (process.env.NODE_ENV !== 'production') {
        if (ReactFiberInstrumentation.debugTool) {
          if (current.alternate === null) {
            ReactFiberInstrumentation.debugTool.onMountContainer(root);
          } else if (element === null) {
            ReactFiberInstrumentation.debugTool.onUnmountContainer(root);
          } else {
            ReactFiberInstrumentation.debugTool.onUpdateContainer(root);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (root.context === null) {
        root.context = context;
      } else {
        root.pendingContext = context;
      }

      scheduleTopLevelUpdate(current, element, callback);
    },


    performWithPriority: performWithPriority,

    batchedUpdates: batchedUpdates,

    unbatchedUpdates: unbatchedUpdates,

    syncUpdates: syncUpdates,

    deferredUpdates: deferredUpdates,

    getPublicRootInstance: function (container) {
      var root = container.stateNode;
      var containerFiber = root.current;
      if (!containerFiber.child) {
        return null;
      }
      return containerFiber.child.stateNode;
    },
    findHostInstance: function (fiber) {
      var hostFiber = findCurrentHostFiber(fiber);
      if (!hostFiber) {
        return null;
      }
      return hostFiber.stateNode;
    }
  };
};